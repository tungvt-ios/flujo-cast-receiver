<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flujo Cast Receiver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        #player {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
        }
        #mirrorCanvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
        }
        #mirrorImg {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 24px;
            text-align: center;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #error {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 20px;
            text-align: center;
            padding: 20px;
        }
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.7);
            font-family: monospace;
            font-size: 14px;
            display: block;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            max-width: 80%;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <!-- Video player for HLS streams -->
    <video id="player" autoplay playsinline></video>

    <!-- Canvas/Image for Screen Mirroring -->
    <canvas id="mirrorCanvas"></canvas>
    <img id="mirrorImg" alt="Screen Mirror">

    <div id="loading">
        <div class="spinner"></div>
        <div id="loadingText">Connecting...</div>
    </div>

    <div id="error">
        <div>Connection Failed</div>
        <div id="errorDetail" style="font-size: 14px; margin-top: 10px; opacity: 0.7;"></div>
    </div>

    <div id="status"></div>

    <!-- HLS.js for HLS stream support -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>

    <!-- Google Cast Receiver SDK -->
    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>

    <script>
        // Elements
        const player = document.getElementById('player');
        const mirrorCanvas = document.getElementById('mirrorCanvas');
        const mirrorImg = document.getElementById('mirrorImg');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const errorDiv = document.getElementById('error');
        const errorDetail = document.getElementById('errorDetail');
        const statusDiv = document.getElementById('status');

        // State
        let hls = null;
        let websocket = null;
        let audioWebsocket = null;
        let audioContext = null;
        let currentMode = null; // 'hls', 'websocket', 'mjpeg'

        // Initialize Cast Receiver
        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();

        // Custom message namespaces
        const IPTV_NAMESPACE = 'urn:x-cast:com.flujo.iptv';
        const MIRROR_NAMESPACE = 'urn:x-cast:com.flujo.mirror';

        // Handle IPTV messages
        context.addCustomMessageListener(IPTV_NAMESPACE, (event) => {
            console.log('IPTV message:', event.data);

            if (event.data.type === 'LOAD_STREAM') {
                loadHLSStream(event.data.url, event.data.title);
            } else if (event.data.type === 'STOP') {
                stopAll();
            }
        });

        // Handle Mirror messages
        context.addCustomMessageListener(MIRROR_NAMESPACE, (event) => {
            console.log('Mirror message:', event.data);
            updateStatus('Mirror msg: ' + event.data.type);

            if (event.data.type === 'START_MIRROR') {
                updateStatus('Start mirror: ' + event.data.url);
                startWebSocketMirror(event.data.url);
            } else if (event.data.type === 'STOP') {
                stopAll();
            }
        });

        // Intercept LOAD requests
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            (loadRequestData) => {
                const url = loadRequestData.media.contentId || loadRequestData.media.contentUrl;
                console.log('=== LOAD INTERCEPTED ===');
                console.log('URL:', url);
                console.log('Full media:', JSON.stringify(loadRequestData.media));
                updateStatus('Received: ' + (url || 'no url').substring(0, 50));

                if (!url) return loadRequestData;

                // Check if WebSocket URL (for screen mirroring)
                if (url.startsWith('ws://') || url.startsWith('wss://')) {
                    console.log('Detected WebSocket URL');
                    startWebSocketMirror(url);
                    return null;
                }

                // Check if HTTP URL for screen mirroring (convert to WebSocket)
                // Screen mirror URLs typically use ports 9080, 9081, etc.
                if ((url.startsWith('http://') || url.startsWith('https://')) &&
                    (url.includes(':9080') || url.includes(':9081') || url.includes(':8765'))) {
                    const wsUrl = url.replace('http://', 'ws://').replace('https://', 'wss://');
                    console.log('Converting HTTP to WebSocket:', wsUrl);
                    startWebSocketMirror(wsUrl);
                    return null;
                }

                // Check contentType for websocket
                if (loadRequestData.media.contentType === 'application/x-websocket') {
                    console.log('Detected websocket contentType, converting URL');
                    const wsUrl = url.replace('http://', 'ws://').replace('https://', 'wss://');
                    startWebSocketMirror(wsUrl.startsWith('ws') ? wsUrl : 'ws://' + url.replace(/^https?:\/\//, ''));
                    return null;
                }

                // Check if HLS stream
                if (url.includes('.m3u8') || url.includes('m3u8')) {
                    console.log('Detected HLS stream');
                    loadHLSStream(url, loadRequestData.media.metadata?.title);
                    return null;
                }

                // Unknown URL type - show error instead of letting default player fail
                console.log('Unknown URL type, showing error');
                showError('Unsupported URL: ' + url.substring(0, 50));
                return null;
            }
        );

        // ==================== HLS STREAMING ====================

        function loadHLSStream(url, title) {
            console.log('Loading HLS stream:', url);
            stopAll();
            currentMode = 'hls';

            showLoading('Loading stream...');
            player.style.display = 'block';

            if (Hls.isSupported()) {
                hls = new Hls({
                    debug: false,
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90
                });

                hls.loadSource(url);
                hls.attachMedia(player);

                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('HLS manifest parsed');
                    hideLoading();
                    player.play().catch(e => console.error('Playback error:', e));
                });

                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('HLS error:', data);
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                hls.recoverMediaError();
                                break;
                            default:
                                showError('Stream error: ' + data.details);
                                break;
                        }
                    }
                });

            } else if (player.canPlayType('application/vnd.apple.mpegurl')) {
                player.src = url;
                player.addEventListener('loadedmetadata', () => {
                    hideLoading();
                    player.play();
                });
            } else {
                showError('HLS not supported');
            }
        }

        // ==================== WEBSOCKET MIRRORING ====================

        function startWebSocketMirror(url) {
            console.log('Starting WebSocket mirror:', url);
            updateStatus('WS connecting: ' + url);
            stopAll();
            currentMode = 'websocket';

            showLoading('Connecting to screen...');
            mirrorImg.style.display = 'block';

            try {
                websocket = new WebSocket(url);
                websocket.binaryType = 'arraybuffer';
            } catch (e) {
                console.error('WebSocket creation error:', e);
                updateStatus('WS create error: ' + e.message);
                showError('Failed to create WebSocket: ' + e.message);
                return;
            }

            websocket.onopen = () => {
                console.log('WebSocket connected');
                hideLoading();
                hideError();
                updateStatus('WS Connected!');
                // Start audio WebSocket
                startAudioWebSocket(url);
            };

            websocket.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer) {
                    // Binary frame (JPEG)
                    displayFrame(event.data);
                } else if (typeof event.data === 'string') {
                    // JSON message
                    try {
                        const msg = JSON.parse(event.data);
                        handleWebSocketMessage(msg);
                    } catch (e) {
                        console.error('Failed to parse message:', e);
                    }
                }
            };

            websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('WS Error');
                showError('WebSocket connection failed');
            };

            websocket.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
                updateStatus('WS Closed: ' + event.code);
                if (currentMode === 'websocket') {
                    // Try to reconnect after 2 seconds
                    setTimeout(() => {
                        if (currentMode === 'websocket') {
                            showLoading('Reconnecting...');
                            startWebSocketMirror(url);
                        }
                    }, 2000);
                }
            };
        }

        function handleWebSocketMessage(msg) {
            if (msg.type === 'config') {
                console.log('Received config:', msg);
            } else if (msg.type === 'stats') {
                updateStatus(`FPS: ${msg.fps || 0}`);
            }
        }

        let pendingFrame = null;
        let frameRequested = false;

        function displayFrame(data) {
            // Hide any errors when receiving frames
            hideError();
            hideLoading();

            // Store latest frame (drop older frames if not yet rendered)
            pendingFrame = data;

            // Use requestAnimationFrame for smooth rendering
            if (!frameRequested) {
                frameRequested = true;
                requestAnimationFrame(renderFrame);
            }
        }

        function renderFrame() {
            frameRequested = false;

            if (!pendingFrame) return;

            const data = pendingFrame;
            pendingFrame = null;

            const blob = new Blob([data], { type: 'image/jpeg' });
            const url = URL.createObjectURL(blob);

            // Revoke previous URL to prevent memory leak
            if (mirrorImg.src && mirrorImg.src.startsWith('blob:')) {
                URL.revokeObjectURL(mirrorImg.src);
            }

            mirrorImg.src = url;
        }

        // ==================== AUDIO STREAMING ====================

        let audioQueue = [];
        let nextPlayTime = 0;
        let audioStarted = false;
        const MAX_QUEUE_SIZE = 10;
        const BUFFER_AHEAD = 0.1; // 100ms buffer ahead

        function startAudioWebSocket(videoUrl) {
            // Derive audio URL from video URL (port 9081 -> 9082)
            const audioUrl = videoUrl.replace(':9081', ':9082');
            if (audioUrl === videoUrl) {
                console.log('Could not derive audio URL from:', videoUrl);
                return;
            }

            console.log('Starting audio WebSocket:', audioUrl);
            updateStatus('Audio connecting...');

            // Initialize AudioContext (let browser choose optimal sample rate)
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('AudioContext created, sampleRate:', audioContext.sampleRate);
            }

            // Reset audio state
            audioQueue = [];
            nextPlayTime = 0;
            audioStarted = false;

            try {
                audioWebsocket = new WebSocket(audioUrl);
                audioWebsocket.binaryType = 'arraybuffer';
            } catch (e) {
                console.error('Audio WebSocket creation error:', e);
                return;
            }

            audioWebsocket.onopen = () => {
                console.log('Audio WebSocket connected');
                updateStatus('Audio connected');
                // Resume audio context (required for autoplay policy)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            };

            audioWebsocket.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer && audioContext) {
                    processAudioChunk(event.data);
                }
            };

            audioWebsocket.onerror = (error) => {
                console.error('Audio WebSocket error:', error);
            };

            audioWebsocket.onclose = () => {
                console.log('Audio WebSocket closed');
                audioStarted = false;
            };
        }

        function processAudioChunk(data) {
            if (data.byteLength < 10) return;

            const view = new DataView(data);
            // Header: sampleRate(4) + channels(2) + dataLength(4) = 10 bytes
            const sampleRate = view.getUint32(0, true);
            const channels = view.getUint16(4, true);
            const dataLength = view.getUint32(6, true);

            if (sampleRate === 0 || channels === 0 || dataLength === 0) return;
            if (data.byteLength < 10 + dataLength) return;

            // Limit queue size to prevent memory buildup
            if (audioQueue.length >= MAX_QUEUE_SIZE) {
                audioQueue.shift(); // Drop oldest
            }

            try {
                // Calculate samples: each sample is 2 bytes (Int16) per channel
                const samples = Math.floor(dataLength / (2 * channels));
                if (samples === 0) return;

                const audioBuffer = audioContext.createBuffer(channels, samples, sampleRate);

                // Convert Int16 PCM to Float32
                for (let c = 0; c < channels; c++) {
                    const channelData = audioBuffer.getChannelData(c);
                    for (let i = 0; i < samples; i++) {
                        // Interleaved format: [L0,R0,L1,R1,...] or mono: [S0,S1,...]
                        const byteOffset = 10 + (i * channels + c) * 2;
                        const sample = view.getInt16(byteOffset, true);
                        channelData[i] = sample / 32768.0;
                    }
                }

                // Queue and schedule
                audioQueue.push(audioBuffer);
                scheduleAudio();
            } catch (e) {
                console.error('Audio processing error:', e);
            }
        }

        function scheduleAudio() {
            while (audioQueue.length > 0) {
                const buffer = audioQueue.shift();
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);

                const currentTime = audioContext.currentTime;

                if (!audioStarted || nextPlayTime < currentTime) {
                    // First buffer or fell behind - start fresh with small buffer
                    nextPlayTime = currentTime + BUFFER_AHEAD;
                    audioStarted = true;
                }

                source.start(nextPlayTime);
                nextPlayTime += buffer.duration;
            }
        }

        function stopAudio() {
            if (audioWebsocket) {
                audioWebsocket.close();
                audioWebsocket = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            audioQueue = [];
            audioStarted = false;
            nextPlayTime = 0;
        }

        // ==================== UTILITIES ====================

        function stopAll() {
            currentMode = null;

            // Stop HLS
            if (hls) {
                hls.destroy();
                hls = null;
            }
            player.style.display = 'none';
            player.pause();
            player.src = '';
            player.load(); // Reset player state

            // Stop WebSocket
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            mirrorImg.style.display = 'none';
            mirrorCanvas.style.display = 'none';

            // Stop Audio
            stopAudio();

            hideLoading();
            hideError();
        }

        function showLoading(text) {
            loadingText.textContent = text || 'Connecting...';
            loading.style.display = 'block';
            errorDiv.style.display = 'none';
        }

        function hideLoading() {
            loading.style.display = 'none';
        }

        function showError(message) {
            hideLoading();
            errorDiv.style.display = 'block';
            errorDetail.textContent = message;
        }

        function hideError() {
            errorDiv.style.display = 'none';
        }

        let statusHistory = [];
        function updateStatus(text) {
            console.log('[Status]', text);
            statusHistory.push(text);
            if (statusHistory.length > 5) statusHistory.shift();
            statusDiv.innerHTML = statusHistory.join('<br>');
            statusDiv.style.display = 'block';
        }

        // Player events
        player.addEventListener('playing', () => {
            hideLoading();
            hideError();
        });

        player.addEventListener('waiting', () => {
            if (currentMode === 'hls') {
                showLoading('Buffering...');
            }
        });

        player.addEventListener('error', (e) => {
            console.error('Player error:', e);
            showError('Playback error');
        });

        // Start the receiver
        const options = new cast.framework.CastReceiverOptions();
        options.disableIdleTimeout = true;

        context.start(options);
        console.log('Flujo Cast Receiver started - supports HLS + WebSocket mirroring');
        updateStatus('Receiver v2.4 ready');
        updateStatus('Waiting for content...');
    </script>
</body>
</html>
