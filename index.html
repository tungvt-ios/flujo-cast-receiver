<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flujo Cast Receiver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        #player {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
        }
        #mirrorCanvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
        }
        #mirrorImg {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 24px;
            text-align: center;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #error {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 20px;
            text-align: center;
            padding: 20px;
        }
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.7);
            font-family: monospace;
            font-size: 14px;
            display: block;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            max-width: 80%;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <!-- Video player for HLS streams -->
    <video id="player" autoplay playsinline></video>

    <!-- Canvas/Image for Screen Mirroring -->
    <canvas id="mirrorCanvas"></canvas>
    <img id="mirrorImg" alt="Screen Mirror">

    <div id="loading">
        <div class="spinner"></div>
        <div id="loadingText">Connecting...</div>
    </div>

    <div id="error">
        <div>Connection Failed</div>
        <div id="errorDetail" style="font-size: 14px; margin-top: 10px; opacity: 0.7;"></div>
    </div>

    <div id="status"></div>

    <!-- HLS.js for HLS stream support -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>

    <!-- Google Cast Receiver SDK -->
    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>

    <script>
        // Elements
        const player = document.getElementById('player');
        const mirrorCanvas = document.getElementById('mirrorCanvas');
        const mirrorImg = document.getElementById('mirrorImg');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const errorDiv = document.getElementById('error');
        const errorDetail = document.getElementById('errorDetail');
        const statusDiv = document.getElementById('status');

        // State
        let hls = null;
        let websocket = null;
        let currentMode = null; // 'hls', 'websocket', 'mjpeg'
        let frameCount = 0;
        let lastFpsUpdate = Date.now();

        // Initialize Cast Receiver
        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();

        // Custom message namespaces
        const IPTV_NAMESPACE = 'urn:x-cast:com.flujo.iptv';
        const MIRROR_NAMESPACE = 'urn:x-cast:com.flujo.mirror';

        // Handle IPTV messages
        context.addCustomMessageListener(IPTV_NAMESPACE, (event) => {
            console.log('IPTV message:', event.data);

            if (event.data.type === 'LOAD_STREAM') {
                loadHLSStream(event.data.url, event.data.title);
            } else if (event.data.type === 'STOP') {
                stopAll();
            }
        });

        // Handle Mirror messages
        context.addCustomMessageListener(MIRROR_NAMESPACE, (event) => {
            console.log('Mirror message:', event.data);
            updateStatus('Mirror msg: ' + event.data.type);

            if (event.data.type === 'START_MIRROR') {
                updateStatus('Start mirror: ' + event.data.url);
                startWebSocketMirror(event.data.url);
            } else if (event.data.type === 'STOP') {
                stopAll();
            }
        });

        // Intercept LOAD requests
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            (loadRequestData) => {
                const url = loadRequestData.media.contentId || loadRequestData.media.contentUrl;
                console.log('=== LOAD INTERCEPTED ===');
                console.log('URL:', url);
                console.log('Full media:', JSON.stringify(loadRequestData.media));
                updateStatus('Received: ' + (url || 'no url').substring(0, 50));

                if (!url) return loadRequestData;

                // Check if WebSocket URL (for screen mirroring)
                if (url.startsWith('ws://') || url.startsWith('wss://')) {
                    console.log('Detected WebSocket URL');
                    startWebSocketMirror(url);
                    return null;
                }

                // Check if HTTP URL for screen mirroring (convert to WebSocket)
                // Screen mirror URLs typically use ports 9080, 9081, etc.
                if ((url.startsWith('http://') || url.startsWith('https://')) &&
                    (url.includes(':9080') || url.includes(':9081') || url.includes(':8765'))) {
                    const wsUrl = url.replace('http://', 'ws://').replace('https://', 'wss://');
                    console.log('Converting HTTP to WebSocket:', wsUrl);
                    startWebSocketMirror(wsUrl);
                    return null;
                }

                // Check contentType for websocket
                if (loadRequestData.media.contentType === 'application/x-websocket') {
                    console.log('Detected websocket contentType, converting URL');
                    const wsUrl = url.replace('http://', 'ws://').replace('https://', 'wss://');
                    startWebSocketMirror(wsUrl.startsWith('ws') ? wsUrl : 'ws://' + url.replace(/^https?:\/\//, ''));
                    return null;
                }

                // Check if HLS stream
                if (url.includes('.m3u8') || url.includes('m3u8')) {
                    console.log('Detected HLS stream');
                    loadHLSStream(url, loadRequestData.media.metadata?.title);
                    return null;
                }

                // Unknown URL type - show error instead of letting default player fail
                console.log('Unknown URL type, showing error');
                showError('Unsupported URL: ' + url.substring(0, 50));
                return null;
            }
        );

        // ==================== HLS STREAMING ====================

        function loadHLSStream(url, title) {
            console.log('Loading HLS stream:', url);
            stopAll();
            currentMode = 'hls';

            showLoading('Loading stream...');
            player.style.display = 'block';

            if (Hls.isSupported()) {
                hls = new Hls({
                    debug: false,
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90
                });

                hls.loadSource(url);
                hls.attachMedia(player);

                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('HLS manifest parsed');
                    hideLoading();
                    player.play().catch(e => console.error('Playback error:', e));
                });

                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('HLS error:', data);
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                hls.recoverMediaError();
                                break;
                            default:
                                showError('Stream error: ' + data.details);
                                break;
                        }
                    }
                });

            } else if (player.canPlayType('application/vnd.apple.mpegurl')) {
                player.src = url;
                player.addEventListener('loadedmetadata', () => {
                    hideLoading();
                    player.play();
                });
            } else {
                showError('HLS not supported');
            }
        }

        // ==================== WEBSOCKET MIRRORING ====================

        function startWebSocketMirror(url) {
            console.log('Starting WebSocket mirror:', url);
            updateStatus('WS connecting: ' + url);
            stopAll();
            currentMode = 'websocket';

            showLoading('Connecting to screen...');
            mirrorImg.style.display = 'block';

            try {
                websocket = new WebSocket(url);
                websocket.binaryType = 'arraybuffer';
            } catch (e) {
                console.error('WebSocket creation error:', e);
                updateStatus('WS create error: ' + e.message);
                showError('Failed to create WebSocket: ' + e.message);
                return;
            }

            websocket.onopen = () => {
                console.log('WebSocket connected');
                hideLoading();
                updateStatus('WS Connected!');
            };

            websocket.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer) {
                    // Binary frame (JPEG)
                    displayFrame(event.data);
                } else if (typeof event.data === 'string') {
                    // JSON message
                    try {
                        const msg = JSON.parse(event.data);
                        handleWebSocketMessage(msg);
                    } catch (e) {
                        console.error('Failed to parse message:', e);
                    }
                }
            };

            websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('WS Error');
                showError('WebSocket connection failed');
            };

            websocket.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
                updateStatus('WS Closed: ' + event.code);
                if (currentMode === 'websocket') {
                    // Try to reconnect after 2 seconds
                    setTimeout(() => {
                        if (currentMode === 'websocket') {
                            showLoading('Reconnecting...');
                            startWebSocketMirror(url);
                        }
                    }, 2000);
                }
            };
        }

        function handleWebSocketMessage(msg) {
            if (msg.type === 'config') {
                console.log('Received config:', msg);
            } else if (msg.type === 'stats') {
                updateStatus(`FPS: ${msg.fps || 0}`);
            }
        }

        function displayFrame(data) {
            const blob = new Blob([data], { type: 'image/jpeg' });
            const url = URL.createObjectURL(blob);

            // Revoke previous URL to prevent memory leak
            if (mirrorImg.src && mirrorImg.src.startsWith('blob:')) {
                URL.revokeObjectURL(mirrorImg.src);
            }

            mirrorImg.src = url;

            // Update FPS counter
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) {
                const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                updateStatus(`FPS: ${fps}`);
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // ==================== UTILITIES ====================

        function stopAll() {
            currentMode = null;

            // Stop HLS
            if (hls) {
                hls.destroy();
                hls = null;
            }
            player.style.display = 'none';
            player.src = '';

            // Stop WebSocket
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            mirrorImg.style.display = 'none';
            mirrorCanvas.style.display = 'none';

            hideLoading();
            hideError();
        }

        function showLoading(text) {
            loadingText.textContent = text || 'Connecting...';
            loading.style.display = 'block';
            errorDiv.style.display = 'none';
        }

        function hideLoading() {
            loading.style.display = 'none';
        }

        function showError(message) {
            hideLoading();
            errorDiv.style.display = 'block';
            errorDetail.textContent = message;
        }

        function hideError() {
            errorDiv.style.display = 'none';
        }

        let statusHistory = [];
        function updateStatus(text) {
            statusHistory.push(text);
            if (statusHistory.length > 5) statusHistory.shift();
            statusDiv.innerHTML = statusHistory.join('<br>');
            statusDiv.style.display = 'block';
        }

        // Player events
        player.addEventListener('playing', () => {
            hideLoading();
            hideError();
        });

        player.addEventListener('waiting', () => {
            if (currentMode === 'hls') {
                showLoading('Buffering...');
            }
        });

        player.addEventListener('error', (e) => {
            console.error('Player error:', e);
            showError('Playback error');
        });

        // Start the receiver
        const options = new cast.framework.CastReceiverOptions();
        options.disableIdleTimeout = true;

        context.start(options);
        console.log('Flujo Cast Receiver started - supports HLS + WebSocket mirroring');
        updateStatus('Receiver v2.0 ready');
        updateStatus('Waiting for content...');
    </script>
</body>
</html>
